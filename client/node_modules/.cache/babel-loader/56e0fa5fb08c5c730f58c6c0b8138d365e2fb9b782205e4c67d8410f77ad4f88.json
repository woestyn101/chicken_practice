{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nexport function useSuspenseQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return wrapHook(\"useSuspenseQuery\", _useSuspenseQuery, useApolloClient(typeof options === \"object\" ? options.client : undefined))(query, options);\n}\nfunction _useSuspenseQuery(query, options) {\n  var client = useApolloClient(options.client);\n  var suspenseCache = getSuspenseCache(client);\n  var watchQueryOptions = useWatchQueryOptions({\n    client: client,\n    query: query,\n    options: options\n  });\n  var fetchPolicy = watchQueryOptions.fetchPolicy,\n    variables = watchQueryOptions.variables;\n  var _a = options.queryKey,\n    queryKey = _a === void 0 ? [] : _a;\n  var cacheKey = __spreadArray([query, canonicalStringify(variables)], [].concat(queryKey), true);\n  var queryRef = suspenseCache.getQueryRef(cacheKey, function () {\n    return client.watchQuery(watchQueryOptions);\n  });\n  var _b = React.useState([queryRef.key, queryRef.promise]),\n    current = _b[0],\n    setPromise = _b[1];\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  var promise = current[1];\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n  React.useEffect(function () {\n    var dispose = queryRef.retain();\n    var removeListener = queryRef.listen(function (promise) {\n      setPromise([queryRef.key, promise]);\n    });\n    return function () {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n  // This effect handles the case where strict mode causes the queryRef to get\n  // disposed early. Previously this was done by using a `setTimeout` inside the\n  // dispose function, but this could cause some issues in cases where someone\n  // might expect the queryRef to be disposed immediately. For example, when\n  // using the same client instance across multiple tests in a test suite, the\n  // `setTimeout` has the possibility of retaining the suspense cache entry for\n  // too long, which means that two tests might accidentally share the same\n  // `queryRef` instance. By immediately disposing, we can avoid this situation.\n  //\n  // Instead we can leverage the work done to allow the queryRef to \"resume\"\n  // after it has been disposed without executing an additional network request.\n  // This is done by calling the `initialize` function below.\n  React.useEffect(function () {\n    if (queryRef.disposed) {\n      // Calling the `dispose` function removes it from the suspense cache, so\n      // when the component rerenders, it instantiates a fresh query ref.\n      // We address this by adding the queryRef back to the suspense cache\n      // so that the lookup on the next render uses the existing queryRef rather\n      // than instantiating a new one.\n      suspenseCache.add(cacheKey, queryRef);\n      queryRef.reinitialize();\n    }\n    // We can omit the deps here to get a fresh closure each render since the\n    // conditional will prevent the logic from running in most cases. This\n    // should also be a touch faster since it should be faster to check the `if`\n    // statement than for React to compare deps on this effect.\n  });\n  var skipResult = React.useMemo(function () {\n    var error = toApolloError(queryRef.result);\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error: error\n    };\n  }, [queryRef.result]);\n  var result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n  var fetchMore = React.useCallback(function (options) {\n    var promise = queryRef.fetchMore(options);\n    setPromise([queryRef.key, queryRef.promise]);\n    return promise;\n  }, [queryRef]);\n  var refetch = React.useCallback(function (variables) {\n    var promise = queryRef.refetch(variables);\n    setPromise([queryRef.key, queryRef.promise]);\n    return promise;\n  }, [queryRef]);\n  var subscribeToMore = React.useCallback(function (options) {\n    return queryRef.observable.subscribeToMore(options);\n  }, [queryRef]);\n  return React.useMemo(function () {\n    return {\n      client: client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore: fetchMore,\n      refetch: refetch,\n      subscribeToMore: subscribeToMore\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\nfunction validateOptions(options) {\n  var query = options.query,\n    fetchPolicy = options.fetchPolicy,\n    returnPartialData = options.returnPartialData;\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\nfunction validateFetchPolicy(fetchPolicy) {\n  if (fetchPolicy === void 0) {\n    fetchPolicy = \"cache-first\";\n  }\n  var supportedFetchPolicies = [\"cache-first\", \"network-only\", \"no-cache\", \"cache-and-network\"];\n  invariant(supportedFetchPolicies.includes(fetchPolicy), 56, fetchPolicy);\n}\nfunction validatePartialDataReturn(fetchPolicy, returnPartialData) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    globalThis.__DEV__ !== false && invariant.warn(57);\n  }\n}\nexport function toApolloError(result) {\n  return isNonEmptyArray(result.errors) ? new ApolloError({\n    graphQLErrors: result.errors\n  }) : result.error;\n}\nexport function useWatchQueryOptions(_a) {\n  var client = _a.client,\n    query = _a.query,\n    options = _a.options;\n  return useDeepMemo(function () {\n    var _a;\n    if (options === skipToken) {\n      return {\n        query: query,\n        fetchPolicy: \"standby\"\n      };\n    }\n    var fetchPolicy = options.fetchPolicy || ((_a = client.defaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || \"cache-first\";\n    var watchQueryOptions = __assign(__assign({}, options), {\n      fetchPolicy: fetchPolicy,\n      query: query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0\n    });\n    if (globalThis.__DEV__ !== false) {\n      validateOptions(watchQueryOptions);\n    }\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n    return watchQueryOptions;\n  }, [client, options, query]);\n}","map":{"version":3,"names":["React","invariant","ApolloError","NetworkStatus","isNonEmptyArray","useApolloClient","DocumentType","verifyDocumentType","__use","useDeepMemo","wrapHook","getSuspenseCache","canonicalStringify","skipToken","useSuspenseQuery","query","options","Object","create","_useSuspenseQuery","client","undefined","suspenseCache","watchQueryOptions","useWatchQueryOptions","fetchPolicy","variables","_a","queryKey","cacheKey","__spreadArray","concat","queryRef","getQueryRef","watchQuery","_b","useState","key","promise","current","setPromise","didChangeOptions","applyOptions","useEffect","dispose","retain","removeListener","listen","disposed","add","reinitialize","skipResult","useMemo","error","toApolloError","result","loading","data","networkStatus","ready","fetchMore","useCallback","refetch","subscribeToMore","observable","validateOptions","returnPartialData","Query","validateFetchPolicy","validatePartialDataReturn","supportedFetchPolicies","includes","globalThis","__DEV__","warn","errors","graphQLErrors","defaultOptions","__assign","notifyOnNetworkStatusChange","nextFetchPolicy","skip"],"sources":["C:\\Users\\zachc\\Documents\\bootcamp\\chicken_practice\\client\\node_modules\\@apollo\\src\\react\\hooks\\useSuspenseQuery.ts"],"sourcesContent":["import * as React from \"rehackt\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../internal/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey, QueryKey } from \"../internal/index.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\" ?\n    TOptions[\"returnPartialData\"] extends true ?\n      DeepPartial<TData> | undefined\n    : TData | undefined\n  : TOptions[\"returnPartialData\"] extends true ?\n    TOptions[\"skip\"] extends boolean ?\n      DeepPartial<TData> | undefined\n    : DeepPartial<TData>\n  : TOptions[\"skip\"] extends boolean ? TData | undefined\n  : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  return wrapHook(\n    \"useSuspenseQuery\",\n    _useSuspenseQuery,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction _useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables>\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ApolloQueryResult<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  // This effect handles the case where strict mode causes the queryRef to get\n  // disposed early. Previously this was done by using a `setTimeout` inside the\n  // dispose function, but this could cause some issues in cases where someone\n  // might expect the queryRef to be disposed immediately. For example, when\n  // using the same client instance across multiple tests in a test suite, the\n  // `setTimeout` has the possibility of retaining the suspense cache entry for\n  // too long, which means that two tests might accidentally share the same\n  // `queryRef` instance. By immediately disposing, we can avoid this situation.\n  //\n  // Instead we can leverage the work done to allow the queryRef to \"resume\"\n  // after it has been disposed without executing an additional network request.\n  // This is done by calling the `initialize` function below.\n  React.useEffect(() => {\n    if (queryRef.disposed) {\n      // Calling the `dispose` function removes it from the suspense cache, so\n      // when the component rerenders, it instantiates a fresh query ref.\n      // We address this by adding the queryRef back to the suspense cache\n      // so that the lookup on the next render uses the existing queryRef rather\n      // than instantiating a new one.\n      suspenseCache.add(cacheKey, queryRef);\n      queryRef.reinitialize();\n    }\n    // We can omit the deps here to get a fresh closure each render since the\n    // conditional will prevent the logic from running in most cases. This\n    // should also be a touch faster since it should be faster to check the `if`\n    // statement than for React to compare deps on this effect.\n  });\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n  const fetchMore = React.useCallback(\n    ((options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    }) satisfies FetchMoreFunction<\n      unknown,\n      OperationVariables\n    > as FetchMoreFunction<TData | undefined, TVariables>,\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<\n    TData | undefined,\n    TVariables\n  > = React.useCallback(\n    (options) => queryRef.observable.subscribeToMore(options),\n    [queryRef]\n  );\n\n  return React.useMemo<\n    UseSuspenseQueryResult<TData | undefined, TVariables>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors) ?\n      new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}